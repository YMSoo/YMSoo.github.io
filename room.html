<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Room</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 100;
            text-align: center;
            transition: opacity 0.5s ease;
        }

        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #instructions {
            margin-top: 1rem;
            font-size: 1.25rem;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1 class="text-4xl font-bold mb-4">Interactive 3D Room</h1>
        <p class="text-lg">Click to begin</p>
        <p id="instructions" class="text-sm">Use W, A, S, D to move and the mouse to look around. Press Esc to exit.</p>
    </div>
    
    <script>
        window.onload = function() {
            // Scene, camera, and renderer setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a202c);
            document.body.appendChild(renderer.domElement);

            // Fog to add depth
            scene.fog = new THREE.Fog(0x1a202c, 0, 15);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(0, 5, 0); // Position the light in the middle, up high
            scene.add(pointLight);

            // Geometry and Materials for the room
            const roomSize = 10;
            const wallColor = 0x6b7280;
            const floorColor = 0x2d3748;

            // Room walls (using groups for easy positioning)
            const roomGroup = new THREE.Group();
            scene.add(roomGroup);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: floorColor });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            roomGroup.add(floor);

            // Walls (using BoxGeometry and a single material)
            const wallMaterial = new THREE.MeshLambertMaterial({ color: wallColor, side: THREE.BackSide });
            const wallHeight = 5;
            const wallThickness = 0.1;

            const backWall = new THREE.Mesh(new THREE.BoxGeometry(roomSize, wallHeight, wallThickness), wallMaterial);
            backWall.position.set(0, wallHeight / 2, -roomSize / 2);
            roomGroup.add(backWall);

            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(roomSize, wallHeight, wallThickness), wallMaterial);
            frontWall.position.set(0, wallHeight / 2, roomSize / 2);
            roomGroup.add(frontWall);

            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, roomSize), wallMaterial);
            leftWall.position.set(-roomSize / 2, wallHeight / 2, 0);
            roomGroup.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, roomSize), wallMaterial);
            rightWall.position.set(roomSize / 2, wallHeight / 2, 0);
            roomGroup.add(rightWall);

            // Add simple furniture objects
            const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
            const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 16);
            const cylinderGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);

            const redMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const greenMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const blueMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });

            const box = new THREE.Mesh(boxGeometry, redMaterial);
            box.position.set(2, 0.5, -3);
            roomGroup.add(box);

            const sphere = new THREE.Mesh(sphereGeometry, greenMaterial);
            sphere.position.set(-3, 0.5, 2);
            roomGroup.add(sphere);

            const cylinder = new THREE.Mesh(cylinderGeometry, blueMaterial);
            cylinder.position.set(0, 1, 3);
            roomGroup.add(cylinder);

            // Player controls using PointerLockControls
            const controls = new THREE.PointerLockControls(camera, renderer.domElement);
            const overlay = document.getElementById('overlay');
            
            // Listen for click to activate controls
            document.addEventListener('click', () => {
                controls.lock();
            });

            // When controls are locked (active), hide the overlay
            controls.addEventListener('lock', () => {
                overlay.classList.add('hidden');
            });

            // When controls are unlocked (user presses Esc), show the overlay
            controls.addEventListener('unlock', () => {
                overlay.classList.remove('hidden');
            });
            
            // Set initial camera position
            camera.position.set(0, 1.5, 0);

            // Player movement logic
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            const movementSpeed = 0.05;
            let moveForward = false;
            let moveBackward = false;
            let moveLeft = false;
            let moveRight = false;
            
            // Keyboard event listeners
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'KeyD':
                        moveRight = true;
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = false;
                        break;
                    case 'KeyS':
                        moveBackward = false;
                        break;
                    case 'KeyA':
                        moveLeft = false;
                        break;
                    case 'KeyD':
                        moveRight = false;
                        break;
                }
            });

            // Handle window resizing
            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            });
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Check if controls are locked to update player movement
                if (controls.isLocked) {
                    // Update movement direction
                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize(); // Ensure constant speed in all directions

                    // Calculate velocity
                    velocity.z = direction.z * movementSpeed;
                    velocity.x = direction.x * movementSpeed;

                    // Move player based on velocity
                    controls.moveForward(velocity.z);
                    controls.moveRight(velocity.x);
                }
                
                renderer.render(scene, camera);
            }

            // Start the animation
            animate();
        };
    </script>
</body>
</html>
