<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Room</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            z-index: 100;
            text-align: center;
            transition: opacity 0.5s ease;
        }

        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #instructions {
            margin-top: 1rem;
            font-size: 1.25rem;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1 class="text-4xl font-bold mb-4">Интерактивная 3D Комната</h1>
        <p class="text-lg">Нажмите, чтобы начать</p>
        <p id="instructions" class="text-sm">Используйте W, A, S, D для движения, мышь для осмотра и пробел для прыжка.</p>
    </div>
    
    <script>
        window.onload = function() {
            // Настройка сцены, камеры и рендера
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a202c);
            document.body.appendChild(renderer.domElement);

            // Туман для глубины
            scene.fog = new THREE.Fog(0x1a202c, 0, 15);

            // Освещение
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(0, 2.375, 0); 
            scene.add(pointLight);

            // Геометрия и материалы для комнаты
            const roomSize = 10;
            const wallColor = 0x6b7280;
            const floorColor = 0x2d3748;
            const furnitureColor = 0x8B0000;
            const stairsColor = 0x7a8393;

            const roomGroup = new THREE.Group();
            scene.add(roomGroup);

            // Пол
            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: floorColor });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            roomGroup.add(floor);

            // Стены (BoxGeometry и один материал)
            const wallMaterial = new THREE.MeshLambertMaterial({ color: wallColor, side: THREE.BackSide });
            const wallHeight = 4.75;
            const wallThickness = 0.1;

            const backWall = new THREE.Mesh(new THREE.BoxGeometry(roomSize, wallHeight, wallThickness), wallMaterial);
            backWall.position.set(0, wallHeight / 2, -roomSize / 2);
            roomGroup.add(backWall);

            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(roomSize, wallHeight, wallThickness), wallMaterial);
            frontWall.position.set(0, wallHeight / 2, roomSize / 2);
            roomGroup.add(frontWall);

            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, roomSize), wallMaterial);
            leftWall.position.set(-roomSize / 2, wallHeight / 2, 0);
            roomGroup.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, roomSize), wallMaterial);
            rightWall.position.set(roomSize / 2, wallHeight / 2, 0);
            roomGroup.add(rightWall);
            
            // Функция для создания плоскости с номером
            function createNumberPlane(number) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const context = canvas.getContext('2d');
                context.font = 'bold 128px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(number, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), material);
                return plane;
            }

            // Добавление номеров на стены
            const backWallNumber = createNumberPlane('1');
            backWallNumber.position.set(0, wallHeight / 2, -roomSize / 2 + 0.05);
            roomGroup.add(backWallNumber);

            const frontWallNumber = createNumberPlane('2');
            frontWallNumber.position.set(0, wallHeight / 2, roomSize / 2 - 0.05);
            frontWallNumber.rotation.y = Math.PI;
            roomGroup.add(frontWallNumber);

            const leftWallNumber = createNumberPlane('3');
            leftWallNumber.position.set(-roomSize / 2 + 0.05, wallHeight / 2, 0);
            leftWallNumber.rotation.y = Math.PI / 2;
            roomGroup.add(leftWallNumber);

            const rightWallNumber = createNumberPlane('4');
            rightWallNumber.position.set(roomSize / 2 - 0.05, wallHeight / 2, 0);
            rightWallNumber.rotation.y = -Math.PI / 2;
            roomGroup.add(rightWallNumber);


            // Добавление мебели
            // Стол
            const tableGroup = new THREE.Group();
            const tableTop = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 1), new THREE.MeshLambertMaterial({ color: 0x964B00 }));
            tableTop.position.y = 0.75;
            const tableLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.75, 0.1), new THREE.MeshLambertMaterial({ color: 0x964B00 }));
            tableLeg1.position.set(-0.9, 0.375, -0.4);
            const tableLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.75, 0.1), new THREE.MeshLambertMaterial({ color: 0x964B00 }));
            tableLeg2.position.set(0.9, 0.375, -0.4);
            const tableLeg3 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.75, 0.1), new THREE.MeshLambertMaterial({ color: 0x964B00 }));
            tableLeg3.position.set(-0.9, 0.375, 0.4);
            const tableLeg4 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.75, 0.1), new THREE.MeshLambertMaterial({ color: 0x964B00 }));
            tableLeg4.position.set(0.9, 0.375, 0.4);
            tableGroup.add(tableTop, tableLeg1, tableLeg2, tableLeg3, tableLeg4);
            tableGroup.position.set(2, 0, -3);
            roomGroup.add(tableGroup);

            // Стул
            const chairGroup = new THREE.Group();
            const chairMaterial = new THREE.MeshLambertMaterial({ color: 0x483C32 });

            const chairSeat = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.5), chairMaterial);
            chairSeat.position.y = 0.3;
            chairGroup.add(chairSeat);

            const chairBack = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.1), chairMaterial);
            chairBack.position.set(0, 0.6, -0.2);
            chairGroup.add(chairBack);

            // Ножки стула
            const legHeight = 0.3;
            const legGeometry = new THREE.BoxGeometry(0.05, legHeight, 0.05);

            const frontLeftLeg = new THREE.Mesh(legGeometry, chairMaterial);
            frontLeftLeg.position.set(-0.2, legHeight / 2, 0.2);
            chairGroup.add(frontLeftLeg);
            
            const frontRightLeg = new THREE.Mesh(legGeometry, chairMaterial);
            frontRightLeg.position.set(0.2, legHeight / 2, 0.2);
            chairGroup.add(frontRightLeg);
            
            const backLeftLeg = new THREE.Mesh(legGeometry, chairMaterial);
            backLeftLeg.position.set(-0.2, legHeight / 2, -0.2);
            chairGroup.add(backLeftLeg);
            
            const backRightLeg = new THREE.Mesh(legGeometry, chairMaterial);
            backRightLeg.position.set(0.2, legHeight / 2, -0.2);
            chairGroup.add(backRightLeg);

            chairGroup.position.set(2, 0.05, -1.5); // Позиция стула
            chairGroup.rotation.y = Math.PI; // Поворот стула на 180 градусов
            roomGroup.add(chairGroup);

            // Диван
            const sofaGroup = new THREE.Group();
            const sofaBase = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.3, 1), new THREE.MeshLambertMaterial({ color: 0x8B0000 }));
            sofaBase.position.y = 0.15;
            const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1, 0.2), new THREE.MeshLambertMaterial({ color: 0x8B0000 }));
            sofaBack.position.set(0, 0.5, -0.4);
            sofaGroup.add(sofaBase, sofaBack);
            sofaGroup.position.set(-4.5, 0, 0); // Позиция дивана у левой стены
            sofaGroup.rotation.y = Math.PI / 2; // Поворот дивана на 90 градусов
            roomGroup.add(sofaGroup);
            
            // Телевизор и тумбочка
            const tvStandGroup = new THREE.Group();
            const tvStandBase = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 0.4), new THREE.MeshLambertMaterial({ color: 0x5C4033 }));
            tvStandBase.position.y = 0.25;
            tvStandGroup.add(tvStandBase);
            
            const tvScreen = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.9, 0.05), new THREE.MeshLambertMaterial({ color: 0x222222 }));
            tvScreen.position.y = 0.5 + (0.9 / 2); // Позиция ТВ относительно тумбочки
            tvStandGroup.add(tvScreen);

            tvStandGroup.position.set(4.5, 0, 0); // Позиция тумбочки с телевизором у правой стены
            tvStandGroup.rotation.y = -Math.PI / 2; // Поворот всей группы
            roomGroup.add(tvStandGroup);

            // Добавление лестницы к стене 2 и ее поворот
            const stairsGroup = new THREE.Group();
            const stairSteps = [];
            const stepWidth = 4.0;
            const stepHeight = 0.2;
            const stepDepth = 0.3;
            const numberOfSteps = 24;
            const stairsMaterial = new THREE.MeshLambertMaterial({ color: stairsColor });

            for (let i = 0; i < numberOfSteps; i++) {
                const step = new THREE.Mesh(new THREE.BoxGeometry(stepWidth, stepHeight, stepDepth), stairsMaterial);
                step.position.set(
                    0,
                    (i * stepHeight) + (stepHeight / 2),
                    (i * stepDepth)
                );
                stairsGroup.add(step);
                stairSteps.push(step);
            }

            stairsGroup.rotation.y = Math.PI / 2; // Поворот лестницы
            stairsGroup.position.set(-2.0, 0, roomSize / 2 - 0.05); // Позиция лестницы
            roomGroup.add(stairsGroup);

            // Массив для хранения всех объектов для проверки столкновений
            const collisionObjects = [
                backWall, frontWall, leftWall, rightWall,
                tableGroup,
                chairGroup,
                sofaGroup,
                tvStandGroup
            ];

            // Управление игроком с помощью PointerLockControls
            const controls = new THREE.PointerLockControls(camera, renderer.domElement);
            const overlay = document.getElementById('overlay');
            
            // Нажмите, чтобы активировать управление
            document.addEventListener('click', () => {
                controls.lock();
            });

            // Когда управление заблокировано, скрыть наложение
            controls.addEventListener('lock', () => {
                overlay.classList.add('hidden');
            });

            // Когда управление разблокировано, показать наложение
            controls.addEventListener('unlock', () => {
                overlay.classList.remove('hidden');
            });
            
            // Установить начальную позицию камеры
            camera.position.set(0, 1.5, 0);

            // Логика движения игрока
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            const movementSpeed = 0.05;
            const playerHeight = 1.5;
            const gravity = -0.01; // Гравитация в 5 раз слабее
            const jumpPower = 0.2;

            let canJump = false;
            let moveForward = false;
            let moveBackward = false;
            let moveLeft = false;
            let moveRight = false;
            
            // Слушатели событий клавиатуры
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = true;
                        break;
                    case 'KeyS':
                        moveBackward = true;
                        break;
                    case 'KeyA':
                        moveLeft = true;
                        break;
                    case 'KeyD':
                        moveRight = true;
                        break;
                    case 'Space':
                        if (canJump) {
                            velocity.y = jumpPower;
                            canJump = false;
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        moveForward = false;
                        break;
                    case 'KeyS':
                        moveBackward = false;
                        break;
                    case 'KeyA':
                        moveLeft = false;
                        break;
                    case 'KeyD':
                        moveRight = false;
                        break;
                }
            });

            // Обработка изменения размера окна
            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                renderer.setSize(width, height);
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            });
            
            // Цикл анимации
            function animate() {
                requestAnimationFrame(animate);

                // Проверка, заблокировано ли управление для обновления движения игрока
                if (controls.isLocked) {
                    const oldPosition = camera.position.clone();

                    // Обновление направления движения
                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize();

                    // Применение движения
                    controls.moveForward(direction.z * movementSpeed);
                    controls.moveRight(direction.x * movementSpeed);

                    // Применение гравитации и обновление вертикальной скорости
                    velocity.y += gravity;
                    camera.position.y += velocity.y;
                    
                    // Проверка столкновений
                    let collisionDetected = false;
                    const playerBox = new THREE.Box3();
                    const playerSize = new THREE.Vector3(0.5, 1.5, 0.5);
                    playerBox.setFromCenterAndSize(camera.position, playerSize);

                    // Столкновения со стенами и мебелью
                    for (const object of collisionObjects) {
                        const objectBox = new THREE.Box3().setFromObject(object);
                        if (playerBox.intersectsBox(objectBox)) {
                            collisionDetected = true;
                            break;
                        }
                    }

                    // Если обнаружено столкновение, отменить движение
                    if (collisionDetected) {
                        camera.position.copy(oldPosition);
                    }

                    // Проверка столкновения с полом
                    if (camera.position.y <= playerHeight) {
                        camera.position.y = playerHeight;
                        velocity.y = 0;
                        canJump = true;
                    }

                    // Проверка столкновения со ступеньками
                    let onStair = false;
                    stairSteps.forEach(step => {
                        const stepWorldPos = new THREE.Vector3();
                        step.getWorldPosition(stepWorldPos);

                        const stepWorldBox = new THREE.Box3().setFromObject(step);
                        
                        // Check if player is on the step
                        if (playerBox.intersectsBox(stepWorldBox)) {
                            // Check if the player is above the step
                            if (oldPosition.y > stepWorldPos.y + stepHeight / 2) {
                                camera.position.y = stepWorldPos.y + stepHeight / 2 + playerHeight / 2;
                                velocity.y = 0;
                                canJump = true;
                                onStair = true;
                            }
                        }
                    });
                }
                
                renderer.render(scene, camera);
            }

            // Запуск анимации
            animate();
        };
    </script>
</body>
</html>
