<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Модель Стива из Minecraft</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #info-box {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: right;
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        #button-container {
            position: absolute;
            bottom: 20px;
            display: flex;
            gap: 1rem;
            z-index: 10;
        }

        canvas {
            touch-action: none; /* Disable touch gestures for better control */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="info-box">
            <h2 class="text-xl font-bold">Управление</h2>
            <p><strong>A:</strong> Толкнуть влево</p>
            <p><strong>D:</strong> Толкнуть вправо</p>
            <p><strong>W:</strong> Толкнуть вперёд</p>
            <p><strong>S:</strong> Толкнуть назад</p>
            <p><strong>Q:</strong> Толкнуть вверх</p>
            <p><strong>E:</strong> Толкнуть вниз</p>
            <p><strong>R:</strong> Переключить вид камеры</p>
        </div>
        <div id="button-container">
            <button id="reset-view-button" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-full shadow-lg">Сбросить вид</button>
        </div>
        <canvas id="steve-canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        window.onload = function () {
            // --- Three.js Setup ---
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x334155);
            
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(new THREE.Vector3(0, 2, 0));

            const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('steve-canvas') });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);

            // Ground Plane
            const groundMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 20),
                new THREE.MeshStandardMaterial({ color: 0x4a5568 })
            );
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // --- Cannon.js Setup ---
            const world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Ground body
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            // Invisible cubic barrier
            const barrierSize = 20; // Увеличена, чтобы дать больше места
            const wallThickness = 1; // Возвращена к исходному значению

            // Top wall
            const topWallShape = new CANNON.Box(new CANNON.Vec3(barrierSize / 2, wallThickness / 2, barrierSize / 2));
            const topWallBody = new CANNON.Body({ mass: 0 });
            topWallBody.addShape(topWallShape);
            topWallBody.position.set(0, barrierSize / 2, 0);
            world.addBody(topWallBody);

            // Left wall
            const leftWallShape = new CANNON.Box(new CANNON.Vec3(wallThickness / 2, barrierSize / 2, barrierSize / 2));
            const leftWallBody = new CANNON.Body({ mass: 0 });
            leftWallBody.addShape(leftWallShape);
            leftWallBody.position.set(-barrierSize / 2, barrierSize / 4, 0);
            world.addBody(leftWallBody);

            // Right wall
            const rightWallShape = new CANNON.Box(new CANNON.Vec3(wallThickness / 2, barrierSize / 2, barrierSize / 2));
            const rightWallBody = new CANNON.Body({ mass: 0 });
            rightWallBody.addShape(rightWallShape);
            rightWallBody.position.set(barrierSize / 2, barrierSize / 4, 0);
            world.addBody(rightWallBody);

            // Back wall
            const backWallShape = new CANNON.Box(new CANNON.Vec3(barrierSize / 2, barrierSize / 2, wallThickness / 2));
            const backWallBody = new CANNON.Body({ mass: 0 });
            backWallBody.addShape(backWallShape);
            backWallBody.position.set(0, barrierSize / 4, -barrierSize / 2);
            world.addBody(backWallBody);

            // Front wall
            const frontWallShape = new CANNON.Box(new CANNON.Vec3(barrierSize / 2, barrierSize / 2, wallThickness / 2));
            const frontWallBody = new CANNON.Body({ mass: 0 });
            frontWallBody.addShape(frontWallShape);
            frontWallBody.position.set(0, barrierSize / 4, barrierSize / 2);
            world.addBody(frontWallBody);

            // Steve body parts with physics
            const bodies = {};
            const meshes = {};
            const steveGroup = new THREE.Group();
            scene.add(steveGroup);

            // Increased height factor
            const heightFactor = 1.25; 

            const partData = {
                'head': { size: [1, 1, 1], pos: [0, 2.0 * heightFactor + 1.0 + 0.5, 0] },
                'torso': { size: [1, 2.0 * heightFactor, 0.5], pos: [0, 1.0 * heightFactor + 1.0, 0] },
                'left_arm': { size: [0.5, 2.0 * heightFactor, 0.5], pos: [-(0.5 + 0.25), 1.0 * heightFactor + 1.0, 0] },
                'right_arm': { size: [0.5, 2.0 * heightFactor, 0.5], pos: [0.5 + 0.25, 1.0 * heightFactor + 1.0, 0] },
                'left_leg': { size: [0.5, 2.0 * heightFactor, 0.5], pos: [-0.25, 0.5 * heightFactor, 0] },
                'right_leg': { size: [0.5, 2.0 * heightFactor, 0.5], pos: [0.25, 0.5 * heightFactor, 0] },
            };
            

            const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDAB9, roughness: 0.8 });
            const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x3D2D1B, roughness: 0.8 });
            const shirtMaterial = new THREE.MeshStandardMaterial({ color: 0x436474, roughness: 0.8 });
            const pantsMaterial = new THREE.MeshStandardMaterial({ color: 0x242475, roughness: 0.8 });
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x8B0000 });
            const bloodMaterial = new THREE.MeshBasicMaterial({ color: 0xAA0000 });

            function createSteve() {
                // Clear existing parts and constraints
                for (const name in bodies) {
                    world.removeBody(bodies[name]);
                }
                while (steveGroup.children.length > 0) {
                    steveGroup.remove(steveGroup.children[0]);
                }
                world.constraints.length = 0;

                // Create and add parts
                for (const name in partData) {
                    const data = partData[name];
                    const shape = new CANNON.Box(new CANNON.Vec3(data.size[0] / 2, data.size[1] / 2, data.size[2] / 2));
                    const body = new CANNON.Body({ mass: 1 });
                    body.addShape(shape);
                    body.position.set(...data.pos);
                    world.addBody(body);
                    bodies[name] = body;

                    let material;
                    // Assign material based on part name
                    if (name === 'head' || name === 'left_arm' || name === 'right_arm' || name === 'middle_leg') {
                        material = skinMaterial;
                    } else if (name === 'torso') {
                        material = shirtMaterial;
                    } else {
                        material = pantsMaterial;
                    }

                    const mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(...data.size),
                        material
                    );
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    meshes[name] = mesh;
                    steveGroup.add(mesh);
                }

                // Add face details to the head mesh
                const headMesh = meshes['head'];
                const leftEyeMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.1), eyeMaterial);
                leftEyeMesh.position.set(-0.2, 0.1, 0.5);
                headMesh.add(leftEyeMesh);
                
                const rightEyeMesh = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.1), eyeMaterial);
                rightEyeMesh.position.set(0.2, 0.1, 0.5);
                headMesh.add(rightEyeMesh);
                
                const mouthMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), mouthMaterial);
                mouthMesh.position.set(0, -0.2, 0.5);
                headMesh.add(mouthMesh);

                // --- Updated Hair Geometry and Position ---
                // New hair geometry: a thin cap that sits on top of the head
                const hairMesh = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.2, 1.1), hairMaterial);
                hairMesh.position.set(0, 0.5, 0); // Position it on top of the head
                headMesh.add(hairMesh);

                // Add joints to connect the body parts using PointToPointConstraint for "springy" behavior
                const stiffness = 1000;
                const damping = 50;

                // Neck joint
                const neckPivotA = new CANNON.Vec3(0, partData['torso'].size[1] / 2, 0);
                const neckPivotB = new CANNON.Vec3(0, -partData['head'].size[1] / 2, 0);
                const neckConstraint = new CANNON.PointToPointConstraint(bodies['torso'], neckPivotA, bodies['head'], neckPivotB);
                world.addConstraint(neckConstraint);
                neckConstraint.stiffness = stiffness;
                neckConstraint.damping = damping;

                // Left Shoulder joint
                const leftShoulderPivotA = new CANNON.Vec3(-partData['torso'].size[0] / 2, partData['torso'].size[1] / 2, 0);
                const leftShoulderPivotB = new CANNON.Vec3(partData['left_arm'].size[0] / 2, partData['left_arm'].size[1] / 2, 0);
                const leftShoulderConstraint = new CANNON.PointToPointConstraint(bodies['torso'], leftShoulderPivotA, bodies['left_arm'], leftShoulderPivotB);
                world.addConstraint(leftShoulderConstraint);
                leftShoulderConstraint.stiffness = stiffness;
                leftShoulderConstraint.damping = damping;
                
                // Right Shoulder joint
                const rightShoulderPivotA = new CANNON.Vec3(partData['torso'].size[0] / 2, partData['torso'].size[1] / 2, 0);
                const rightShoulderPivotB = new CANNON.Vec3(-partData['right_arm'].size[0] / 2, partData['right_arm'].size[1] / 2, 0);
                const rightShoulderConstraint = new CANNON.PointToPointConstraint(bodies['torso'], rightShoulderPivotA, bodies['right_arm'], rightShoulderPivotB);
                world.addConstraint(rightShoulderConstraint);
                rightShoulderConstraint.stiffness = stiffness;
                rightShoulderConstraint.damping = damping;

                // Left Hip joint
                const leftHipPivotA = new CANNON.Vec3(-partData['torso'].size[0] / 2, -partData['torso'].size[1] / 2, 0);
                const leftHipPivotB = new CANNON.Vec3(partData['left_leg'].size[0] / 2, partData['left_leg'].size[1] / 2, 0);
                const leftHipConstraint = new CANNON.PointToPointConstraint(bodies['torso'], leftHipPivotA, bodies['left_leg'], leftHipPivotB);
                world.addConstraint(leftHipConstraint);
                leftHipConstraint.stiffness = stiffness;
                leftHipConstraint.damping = damping;
                
                // Right Hip joint
                const rightHipPivotA = new CANNON.Vec3(partData['torso'].size[0] / 2, -partData['torso'].size[1] / 2, 0);
                const rightHipPivotB = new CANNON.Vec3(-partData['right_leg'].size[0] / 2, partData['right_leg'].size[1] / 2, 0);
                const rightHipConstraint = new CANNON.PointToPointConstraint(bodies['torso'], rightHipPivotA, bodies['right_leg'], rightHipPivotB);
                world.addConstraint(rightHipConstraint);
                rightHipConstraint.stiffness = stiffness;
                rightHipConstraint.damping = damping;
            }
            createSteve();
            
            let isTopView = false;
            let pushCounter = 0;
            const bloodParticles = [];

            function createBloodEffect(position) {
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 8, 8),
                        bloodMaterial
                    );
                    particle.position.copy(position);
                    
                    // Give particles a random initial velocity
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 5,
                        (Math.random() - 0.5) * 5
                    );
                    
                    particle.velocity = velocity;
                    particle.lifetime = 60; // particles exist for 60 frames
                    
                    scene.add(particle);
                    bloodParticles.push(particle);
                }
            }

            function toggleCameraView() {
                if (isTopView) {
                    // Switch to side view
                    camera.position.set(0, 5, 10);
                    camera.lookAt(new THREE.Vector3(0, 2, 0));
                    isTopView = false;
                } else {
                    // Switch to top-down view
                    camera.position.set(0, 15, 0);
                    camera.lookAt(new THREE.Vector3(0, 0, 0));
                    isTopView = true;
                }
            }

            // --- Keyboard interaction logic ---
            const pushForce = 50; // Adjusted force for a softer push
            
            window.addEventListener('keydown', (e) => {
                let impulseDirection = new CANNON.Vec3();

                // Get direction based on key press
                switch(e.key.toLowerCase()) {
                    case 'w': // Forward
                        impulseDirection.set(0, 0, -1);
                        break;
                    case 's': // Backward
                        impulseDirection.set(0, 0, 1);
                        break;
                    case 'a': // Left
                        impulseDirection.set(-1, 0, 0);
                        break;
                    case 'd': // Right
                        impulseDirection.set(1, 0, 0);
                        break;
                    case 'q': // Up
                        impulseDirection.set(0, 1, 0);
                        break;
                    case 'e': // Down
                        impulseDirection.set(0, -1, 0);
                        break;
                    case 'r': // Toggle camera view
                        toggleCameraView();
                        break;
                }

                if (impulseDirection.length() > 0) {
                    pushCounter++;
                    if (pushCounter % 10 === 0) {
                        createBloodEffect(meshes['torso'].position);
                    }
                    impulseDirection.normalize();
                    impulseDirection.scale(pushForce, impulseDirection);
                    bodies['torso'].applyImpulse(impulseDirection, new CANNON.Vec3(0, 0.5, 0)); // Apply force to the torso
                }
            });

            // Button event listener
            document.getElementById('reset-view-button').addEventListener('click', () => {
                camera.position.set(0, 5, 10);
                camera.lookAt(new THREE.Vector3(0, 2, 0));
                isTopView = false;
                // Reset Steve's position and orientation
                for (const name in bodies) {
                    bodies[name].position.set(...partData[name].pos);
                    bodies[name].velocity.set(0, 0, 0);
                    bodies[name].angularVelocity.set(0, 0, 0);
                    bodies[name].quaternion.set(0, 0, 0, 1);
                }
                pushCounter = 0; // Reset counter
            });
            
            // Animation loop
            const timeStep = 1 / 60;
            function animate() {
                requestAnimationFrame(animate);
                world.step(timeStep);
                
                for (const name in bodies) {
                    meshes[name].position.copy(bodies[name].position);
                    meshes[name].quaternion.copy(bodies[name].quaternion);
                }
                
                // Update blood particles
                for (let i = bloodParticles.length - 1; i >= 0; i--) {
                    const p = bloodParticles[i];
                    p.velocity.y -= world.gravity.y * timeStep * 0.1; // Apply gravity
                    p.position.addScaledVector(p.velocity, timeStep);
                    p.lifetime--;
                    if (p.lifetime <= 0) {
                        scene.remove(p);
                        bloodParticles.splice(i, 1);
                    }
                }

                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        };
    </script>
</body>
</html>
